from flask import Flask, render_template, request, jsonify, redirect, url_for, session
from pyairtable import Api
import os
from dotenv import load_dotenv
from datetime import datetime
from agents.lia_agent import get_lia_response  # Import the LIA agent

# Load environment variables
load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY", "your-secret-key-here")  # Load from .env or use default

# Airtable setup
AIRTABLE_PAT = os.getenv("AIRTABLE_PAT")
AIRTABLE_BASE_ID = os.getenv("AIRTABLE_BASE_ID")
TABLE_NAME = "Content Schedule"

if not AIRTABLE_PAT or not AIRTABLE_BASE_ID:
    raise ValueError("AIRTABLE_PAT and AIRTABLE_BASE_ID must be set in the .env file")

airtable = Api(AIRTABLE_PAT).table(AIRTABLE_BASE_ID, TABLE_NAME)

# In-memory user storage (replace with a database in production)
users = {
    "admin": "password123"  # Default admin user
}

# Custom filter to convert ISO 8601 to datetime-local format
@app.template_filter('datetime_local')
def datetime_local(value):
    if not value:
        return ''
    try:
        dt = datetime.strptime(value, "%Y-%m-%dT%H:%M:%S.%fZ")
        return dt.strftime("%Y-%m-%dT%H:%M")
    except ValueError as e:
        print(f"Error parsing date: {str(e)}")
        return ''

# Register route
@app.route('/register', methods=['GET', 'POST'])
def register():
    if session.get('logged_in'):
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if not username or not password:
            return render_template('register.html', error="Username and password are required")
        
        if username in users:
            return render_template('register.html', error="Username already exists")
        
        # Add the new user to the in-memory storage
        users[username] = password
        print(f"Registered new user: {username}")
        return redirect(url_for('login'))
    
    return render_template('register.html')

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if session.get('logged_in'):
        return redirect(url_for('home'))
    
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if username in users and users[username] == password:
            session['logged_in'] = True
            session['username'] = username  # Store username in session
            return redirect(url_for('home'))
        else:
            return render_template('login.html', error="Invalid username or password")
    return render_template('login.html')

# Logout route
@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    session.pop('username', None)
    return redirect(url_for('login'))

# Home route (protected)
@app.route('/')
def home():
    if not session.get('logged_in'):
        return redirect(url_for('login'))
    try:
        records = airtable.all()
        print("Raw Airtable Records:", records)
        schedule_data = [{'id': record['id'], 'fields': record['fields']} for record in records]
        return render_template('home.html', schedule=schedule_data, username=session.get('username'))
    except Exception as e:
        print(f"Error fetching records: {str(e)}")
        return "Error fetching records", 500

# Add content route (now returns JSON for AJAX)
@app.route('/add', methods=['POST'])
def add_new_content():
    try:
        post_title = request.form.get('Post title')
        content_type = request.form.get('Content type')
        scheduled_date = request.form.get('Scheduled date')
        draft_link = request.form.get('Draft link', None)
        
        if not post_title or not content_type or not scheduled_date:
            return jsonify({"success": False, "error": "Missing required fields"}), 400
        
        if 'T' in scheduled_date and scheduled_date.endswith('Z'):
            iso_date = scheduled_date
        else:
            dt = datetime.strptime(scheduled_date, "%Y-%m-%dT%H:%M")
            iso_date = dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
        
        new_record = {
            "Post title": post_title,
            "Content type": content_type,
            "Scheduled date": iso_date,
            "Status": "Draft",
            "Draft link": draft_link if draft_link else "",
            "Notes": "Generated by AI Agent"
        }
        print("Inserting new record:", new_record)
        record = airtable.create(new_record, typecast=True)
        return jsonify({"success": True, "record": record})
    except Exception as e:
        print(f"Error adding content: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# Update content route (only update provided fields)
@app.route('/update/<record_id>', methods=['POST'])
def update_content(record_id):
    try:
        data = request.get_json()
        updated_record = {}

        for field in ['Post title', 'Content type', 'Scheduled date', 'Status', 'Draft link', 'Notes']:
            if field in data and data[field] is not None:
                if field == 'Scheduled date' and data[field] and not data[field].endswith('Z'):
                    dt = datetime.strptime(data[field], "%Y-%m-%dT%H:%M")
                    updated_record[field] = dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
                else:
                    updated_record[field] = data[field]

        print("Updating record ID:", record_id)
        print("Update payload:", updated_record)
        if not updated_record:
            return jsonify({"success": False, "error": "No fields to update"}), 400

        response = airtable.update(record_id, updated_record, typecast=True)
        print("Update response:", response)
        return jsonify({"success": True, "record": response})
    except Exception as e:
        print(f"Error updating record: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# Delete content route
@app.route('/delete/<record_id>', methods=['POST'])
def delete_content(record_id):
    try:
        airtable.delete(record_id)
        return jsonify({"success": True})
    except Exception as e:
        print(f"Error deleting record: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# LIA route for the new agent
@app.route('/lia', methods=['POST'])
def lia():
    data = request.get_json()
    message = data.get('message', '')
    if not message:
        return jsonify({"response": "Error: No message provided."}), 400
    
    # Get response from the LIA agent
    response = get_lia_response(message)
    return jsonify({"response": response})

if __name__ == "__main__":
    app.run(debug=True)