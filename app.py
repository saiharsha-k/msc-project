from flask import Flask, render_template, request, jsonify, redirect, url_for, session
from pyairtable import Api
import os
from dotenv import load_dotenv
from datetime import datetime
from agents.lia_agent import get_lia_response  # Import the LIA agent

# Load environment variables
load_dotenv()

app = Flask(__name__)
app.secret_key = 'your-secret-key-here'  # Replace with a secure key

# Airtable setup
AIRTABLE_PAT = os.getenv("AIRTABLE_PAT")
AIRTABLE_BASE_ID = os.getenv("AIRTABLE_BASE_ID")
TABLE_NAME = "Content Schedule"
airtable = Api(AIRTABLE_PAT).table(AIRTABLE_BASE_ID, TABLE_NAME)

# Custom filter to convert ISO 8601 to datetime-local format
@app.template_filter('datetime_local')
def datetime_local(value):
    if not value:
        return ''
    try:
        dt = datetime.strptime(value, "%Y-%m-%dT%H:%M:%S.%fZ")
        return dt.strftime("%Y-%m-%dT%H:%M")
    except ValueError as e:
        print(f"Error parsing date: {str(e)}")
        return ''

# Login route
@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        if username == 'admin' and password == 'password123':
            session['logged_in'] = True
            return redirect(url_for('home'))
        else:
            return render_template('login.html', error="Invalid username or password")
    return render_template('login.html')

# Logout route
@app.route('/logout')
def logout():
    session.pop('logged_in', None)
    return redirect(url_for('login'))

# Home route (protected)
@app.route('/')
def home():
    if not session.get('logged_in'):
        return redirect(url_for('login'))
    try:
        records = airtable.all()
        print("Raw Airtable Records:", records)
        schedule_data = [{'id': record['id'], 'fields': record['fields']} for record in records]
        return render_template('home.html', schedule=schedule_data)
    except Exception as e:
        print(f"Error fetching records: {str(e)}")
        return "Error fetching records", 500

# Add content route (now returns JSON for AJAX)
@app.route('/add', methods=['POST'])
def add_new_content():
    try:
        post_title = request.form['Post title']
        content_type = request.form['Content type']
        scheduled_date = request.form['Scheduled date']
        draft_link = request.form.get('Draft link', None)
        
        if 'T' in scheduled_date and scheduled_date.endswith('Z'):
            iso_date = scheduled_date
        else:
            dt = datetime.strptime(scheduled_date, "%Y-%m-%dT%H:%M")
            iso_date = dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
        
        new_record = {
            "Post title": post_title,
            "Content type": content_type,
            "Scheduled date": iso_date,
            "Status": "Draft",
            "Draft link": draft_link if draft_link else "",
            "Notes": "Generated by AI Agent"
        }
        print("Inserting new record:", new_record)
        record = airtable.create(new_record, typecast=True)
        return jsonify({"success": True, "record": record})
    except Exception as e:
        print(f"Error adding content: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# Update content route (only update provided fields)
@app.route('/update/<record_id>', methods=['POST'])
def update_content(record_id):
    try:
        data = request.get_json()
        updated_record = {}

        for field in ['Post title', 'Content type', 'Scheduled date', 'Status', 'Draft link', 'Notes']:
            if field in data and data[field] is not None:
                if field == 'Scheduled date' and data[field] and not data[field].endswith('Z'):
                    dt = datetime.strptime(data[field], "%Y-%m-%dT%H:%M")
                    updated_record[field] = dt.strftime("%Y-%m-%dT%H:%M:%S.000Z")
                else:
                    updated_record[field] = data[field]

        print("Updating record ID:", record_id)
        print("Update payload:", updated_record)
        if not updated_record:
            return jsonify({"success": False, "error": "No fields to update"}), 400

        response = airtable.update(record_id, updated_record, typecast=True)
        print("Update response:", response)
        return jsonify({"success": True, "record": response})
    except Exception as e:
        print(f"Error updating record: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# Delete content route
@app.route('/delete/<record_id>', methods=['POST'])
def delete_content(record_id):
    try:
        airtable.delete(record_id)
        return jsonify({"success": True})
    except Exception as e:
        print(f"Error deleting record: {str(e)}")
        return jsonify({"success": False, "error": str(e)}), 500

# Chat route (placeholder for AI interaction)
@app.route('/chat', methods=['POST'])
def chat():
    message = request.json['message']
    response = f"Iâ€™m your LinkedIn AI Colleague! How can I help with: {message}"
    return jsonify({"response": response})

# LIA route for the new agent
@app.route('/lia', methods=['POST'])
def lia():
    message = request.json['message']
    response = get_lia_response(message)
    return jsonify({"response": response})

if __name__ == "__main__":
    app.run(debug=True)